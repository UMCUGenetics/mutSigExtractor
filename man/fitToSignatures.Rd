% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitToSignatures.R
\name{fitToSignatures}
\alias{fitToSignatures}
\alias{fitToSignaturesFast}
\alias{fitToSignaturesStrict}
\alias{fitToSignaturesFastStrict}
\title{Linear least-squares (non-negative) fitting}
\usage{
fitToSignatures(
  mut.context.counts,
  signature.profiles,
  use.r.implementation = T,
  verbose = F
)

fitToSignaturesFast(...)

fitToSignaturesStrict(
  mut.context.counts,
  signature.profiles,
  max.delta = 0.004,
  detailed.output = F,
  use.r.implementation = T,
  verbose = F
)

fitToSignaturesFastStrict(...)
}
\arguments{
\item{signature.profiles}{A matrix containing the mutational signature profiles, where rows are
the mutation contexts and the columns are the mutational signatures.}

\item{use.r.implementation}{If TRUE, least squares fitting will be performed using the slow R
function `lsqnonneg()`. If FALSE, the much faster NNLM::nnlm() will be used (written in C++)}

\item{verbose}{Show progress messages?}

\item{max.delta}{See description.}

\item{detailed.output}{Only for `fitToSignaturesStrict()`. Also return results from the
iterative fitting? Includes: cosine similarity between the original and reconstructed mutation
context; signatures removed at each iteration. Useful for plotting fitting performance.}

\item{mut.contexts}{A vector of mutation contexts, or a matrix where rows are samples and columns
are mutation contexts}
}
\value{
If vector is provided to mut.contexts, a vector returned containing the the absolute
contribution of each signature (i.e. the number of mutations contributing to each mutational
signature). If a matrix is provided, a matrix of absolute contributions is returned
}
\description{
Calculate the contribution of each mutational signature in a sample, given a vector
of mutation contexts. This is done by least-squares fitting, i.e. find a linear non-negative
combination of mutation signatures that optimally reconstructs the mutation matrix. This is
performed by `fitToSignatures()`

Only performing least-squares fitting is however potentially prone to overfitting.
`fitToSignaturesStrict()` tries to solve this problem by performing an initial fit, then
iteratively removing the signature with the lowest contribution and with fitting then repeated.
Each time the cosine distance between the original and reconstructed mutation context profile is
calculated. Iterations are stopped when cosine distance > max.delta. The second-last set of
signatures is then returned.
}
